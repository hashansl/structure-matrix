library(maptools)
install.packages("maptools")
install.packages("~/Downloads/maptools_0.2-2.tar.gz", repos = NULL, type = "source")
library(maptools)
install.packages("~/Downloads/maptools_1.1-8.tar.gz", repos = NULL, type = "source")
library(maptools)
library(spdep)
counties<-readShapeSpatial("/data/wyoming/SVI data/SVI2020_US_county.gdb")
counties<-readShapeSpatial("./data/wyoming/SVI data/SVI2020_US_county.gdb")
counties<-readShapeSpatial("/data/SVI2020 WY counties with death rate HepVu/SVI2020_WY_counties_with_death_rate_HepVu.shp")
counties<-readShapeSpatial("./data/SVI2020 WY counties with death rate HepVu/SVI2020_WY_counties_with_death_rate_HepVu.shp")
View(counties)
adj_mat<-nb2mat(poly2nb(counties,queen=T,row.names=counties$COUNTY),style="B")
adj_mat
getAnywhere(poly2nb())
getAnywhere(poly2nb(counties, queen = T, row.names = counties$COUNTY))
getAnywhere(poly2nb)
df <- read.csv("matrix_data.csv")
View(df)
df <- read.csv("matrix_data.csv", header = FALSE)
View(df)
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=n,e=0)))
df <- read.csv("matrix_data.csv", header = FALSE)
library(INLA)
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=n,e=0)))
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=n)))
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=12)))
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=12,e=0)))
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=12,e=0)))
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=12,e=0)))
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=12),e=0))
View(Q)
Q
library(INLA)
df <- read.csv("matrix_data.csv", header = FALSE)
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=12),e=0))
Q
View(Q)
View(Q)
View(Q)
View(Q)
inla.scale.model?
?inla.scale.model
getAnywhere("inla.scale.model")
getAnywhere("inla.scale.model.internal")
diag_sum <- sum(diag(as.matrix(Q)))
print(diag_sum)
diag_sum <- sum(diag(as.matrix(Q)))
print(diag_sum)
print(sqrt(diag_sum))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:n) {
log_diag_sums[i] <- log(Q[i, i])
}
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
print(exp(sum(log_diag_sums)/12))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
print(exp(sum(log_diag_sums)))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
print(exp(sum(log_diag_sums)/12))
library(INLA)
df <- read.csv("matrix_data.csv", header = FALSE)
# Assuming your dataframe is named df
df[df == -1] <- 1
View(df)
Q = inla.scale.model(df, constr=list(A=matrix(1, nrow=1, ncol=12),e=0))
Q
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
print(exp(sum(log_diag_sums)/12))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:13) {
log_diag_sums[i] <- log(Q[i, i])
}
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
print(exp(sum(log_diag_sums)/12))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
print(exp(mean(log_diag_sums)))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(sum(log_diag_sums)/12)
print(exp(mean(log_diag_sums)))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(mean(log_diag_sums))
print(exp(mean(log_diag_sums)))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(mean(log_diag_sums))
print(exp(mean(log_diag_sums)))
# Initialize a vector to store the log sums of diagonal elements
log_diag_sums <- numeric(12)
# Loop through each diagonal element
for (i in 1:12) {
log_diag_sums[i] <- log(Q[i, i])
}
print(log_diag_sums)
print(mean(log_diag_sums))
print(exp(mean(log_diag_sums)))
library(INLA)
#df <- read.csv("matrix_data.csv", header = FALSE)
df <- read.csv("Qmatrix.csv", header = FALSE)
mat <- as.matrix(df)
mat
library(INLA)
#df <- read.csv("matrix_data.csv", header = FALSE)
df <- read.csv("Qmatrix.csv", header = TRUE)
mat <- as.matrix(df)
mat
P = inla.scale.model(mat, constr=list(A=matrix(1, nrow=1, ncol=12),e=0))
P
my_function <- function (Q, constr = NULL, eps = sqrt(.Machine$double.eps))
{
marg.var <- rep(0, nrow(Q))
Q <- inla.as.sparse(Q)
g <- inla.read.graph(Q)
for (k in seq_len(g$cc$n)) {
i <- g$cc$nodes[[k]]
n <- length(i)
QQ <- Q[i, i, drop = FALSE]
if (n == 1) {
QQ[1, 1] <- 1
marg.var[i] <- 1
}
else {
cconstr <- constr
if (!is.null(constr)) {
cconstr$A <- constr$A[, i, drop = FALSE]
eeps <- eps
}
else {
eeps <- 0
}
idx.zero <- which(rowSums(abs(cconstr$A)) == 0)
if (length(idx.zero) > 0) {
cconstr$A <- cconstr$A[-idx.zero, , drop = FALSE]
cconstr$e <- cconstr$e[-idx.zero]
}
res <- inla.qinv(QQ + Diagonal(n) * max(diag(QQ)) *
eeps, constr = cconstr)
fac <- exp(mean(log(diag(res))))
QQ <- fac * QQ
marg.var[i] <- diag(res)/fac
}
#print(Q)
#print(QQ)
Q[i, i] <- QQ
print(Q)
}
return(list(Q = Q, var = marg.var))
}
P = inla.scale.model(mat, constr=list(A=matrix(1, nrow=1, ncol=8),e=0))
P
T = my_function(mat, constr=list(A=matrix(1, nrow=1, ncol=8),e=0))
TT = T$Q
T
T = my_function(mat, constr=list(A=matrix(1, nrow=1, ncol=8),e=0))
TT = T$Q
T
T
my_function <- function (Q, constr = NULL, eps = sqrt(.Machine$double.eps))
{
marg.var <- rep(0, nrow(Q))
Q <- inla.as.sparse(Q)
g <- inla.read.graph(Q)
for (k in seq_len(g$cc$n)) {
i <- g$cc$nodes[[k]]
n <- length(i)
QQ <- Q[i, i, drop = FALSE]
if (n == 1) {
QQ[1, 1] <- 1
marg.var[i] <- 1
}
else {
cconstr <- constr
if (!is.null(constr)) {
cconstr$A <- constr$A[, i, drop = FALSE]
eeps <- eps
}
else {
eeps <- 0
}
idx.zero <- which(rowSums(abs(cconstr$A)) == 0)
if (length(idx.zero) > 0) {
cconstr$A <- cconstr$A[-idx.zero, , drop = FALSE]
cconstr$e <- cconstr$e[-idx.zero]
}
res <- inla.qinv(QQ + Diagonal(n) * max(diag(QQ)) *
eeps, constr = cconstr)
fac <- exp(mean(log(diag(res))))
QQ <- fac * QQ
marg.var[i] <- diag(res)/fac
}
#print(Q)
#print(QQ)
Q[i, i] <- QQ
print(Q)
}
return(list(Q = Q, var = marg.var,fac =fac))
}
T = my_function(mat, constr=list(A=matrix(1, nrow=1, ncol=8),e=0))
TT = T$Q
T
library(INLA)
df <- read.csv("Qmatrix.csv", header = FALSE)
mat <- as.matrix(df)
mat
library(INLA)
df <- read.csv("Qmatrix.csv", header = TRUE)
mat <- as.matrix(df)
mat
P = inla.scale.model(mat, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
P
my_function <- function (Q, constr = NULL, eps = sqrt(.Machine$double.eps))
{
marg.var <- rep(0, nrow(Q))
Q <- inla.as.sparse(Q)
g <- inla.read.graph(Q)
for (k in seq_len(g$cc$n)) {
i <- g$cc$nodes[[k]]
n <- length(i)
QQ <- Q[i, i, drop = FALSE]
if (n == 1) {
QQ[1, 1] <- 1
marg.var[i] <- 1
}
else {
cconstr <- constr
if (!is.null(constr)) {
cconstr$A <- constr$A[, i, drop = FALSE]
eeps <- eps
}
else {
eeps <- 0
}
idx.zero <- which(rowSums(abs(cconstr$A)) == 0)
if (length(idx.zero) > 0) {
cconstr$A <- cconstr$A[-idx.zero, , drop = FALSE]
cconstr$e <- cconstr$e[-idx.zero]
}
res <- inla.qinv(QQ + Diagonal(n) * max(diag(QQ)) *
eeps, constr = cconstr)
fac <- exp(mean(log(diag(res))))
QQ <- fac * QQ
marg.var[i] <- diag(res)/fac
}
#print(Q)
#print(QQ)
Q[i, i] <- QQ
print(Q)
}
return(list(Q = Q, var = marg.var, fac=fac))
}
T = my_function(mat, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
TT = T$Q
T
my_function <- function (Q, constr = NULL, eps = sqrt(.Machine$double.eps))
{
marg.var <- rep(0, nrow(Q))
Q <- inla.as.sparse(Q)
g <- inla.read.graph(Q)
for (k in seq_len(g$cc$n)) {
i <- g$cc$nodes[[k]]
n <- length(i)
QQ <- Q[i, i, drop = FALSE]
if (n == 1) {
QQ[1, 1] <- 1
marg.var[i] <- 1
}
else {
cconstr <- constr
if (!is.null(constr)) {
cconstr$A <- constr$A[, i, drop = FALSE]
eeps <- eps
}
else {
eeps <- 0
}
idx.zero <- which(rowSums(abs(cconstr$A)) == 0)
if (length(idx.zero) > 0) {
cconstr$A <- cconstr$A[-idx.zero, , drop = FALSE]
cconstr$e <- cconstr$e[-idx.zero]
}
res <- inla.qinv(QQ + Diagonal(n) * max(diag(QQ)) *
eeps, constr = cconstr)
fac <- exp(mean(log(diag(res))))
QQ <- fac * QQ
marg.var[i] <- diag(res)/fac
}
#print(Q)
#print(QQ)
Q[i, i] <- QQ
print(Q)
}
return(list(Q = Q, var = marg.var, fac=fac))
}
T = my_function(mat, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
TT = T$Q
T
exp(mean(log(T$var))
exp(mean(log(T$var)))
library(INLA)
mat_crowd <- as.matrix(read.csv("Qmatrix_EP_CROWD.csv", header = TRUE))
library(INLA)
mat_crowd <- as.matrix(read.csv("Qmatrix_EP_CROWD.csv", header = TRUE))
library(INLA)
df_crowd <- read.csv("Qmatrix_EP_CROWD.csv", header = TRUE)
library(INLA)
df_crowd <- read.csv("Qmatrix_EP_CROWD.csv", header = TRUE)
library(INLA)
df_crowd <- read.csv("Qmatrix_EP_CROWD.csv", header = TRUE)
df_disabl <- read.csv("Qmatrix_EP_DISABL.csv", header = TRUE)
df_limeng <- read.csv("Qmatrix_EP_LIMENG.csv", header = TRUE)
df_pci <- read.csv("Qmatrix_EP_PCI.csv", header = TRUE)
df_uninsur <- read.csv("Qmatrix_EP_UNINSUR.csv", header = TRUE)
mat <- as.matrix(df)
mat
library(INLA)
mat_crowd <- as.matrix(read.csv("Qmatrix_EP_CROWD.csv", header = TRUE))
mat_disabl <- as.matrix(read.csv("Qmatrix_EP_DISABL.csv", header = TRUE))
mat_limeng <- as.matrix(read.csv("Qmatrix_EP_LIMENG.csv", header = TRUE))
mat_pci <- as.matrix(read.csv("Qmatrix_EP_PCI.csv", header = TRUE))
mat_uninsur <- as.matrix(read.csv("Qmatrix_EP_UNINSUR.csv", header = TRUE))
my_function <- function (Q, constr = NULL, eps = sqrt(.Machine$double.eps))
{
marg.var <- rep(0, nrow(Q))
Q <- inla.as.sparse(Q)
g <- inla.read.graph(Q)
for (k in seq_len(g$cc$n)) {
i <- g$cc$nodes[[k]]
n <- length(i)
QQ <- Q[i, i, drop = FALSE]
if (n == 1) {
QQ[1, 1] <- 1
marg.var[i] <- 1
}
else {
cconstr <- constr
if (!is.null(constr)) {
cconstr$A <- constr$A[, i, drop = FALSE]
eeps <- eps
}
else {
eeps <- 0
}
idx.zero <- which(rowSums(abs(cconstr$A)) == 0)
if (length(idx.zero) > 0) {
cconstr$A <- cconstr$A[-idx.zero, , drop = FALSE]
cconstr$e <- cconstr$e[-idx.zero]
}
res <- inla.qinv(QQ + Diagonal(n) * max(diag(QQ)) *
eeps, constr = cconstr)
fac <- exp(mean(log(diag(res))))
QQ <- fac * QQ
marg.var[i] <- diag(res)/fac
}
#print(Q)
#print(QQ)
Q[i, i] <- QQ
print(Q)
}
return(list(Q = Q, var = marg.var, fac=fac))
}
mat_crowd.shape
mat_crowd.shape()
dim(mat_crowd)
#INLA_mat_crowd = my_function(mat_crowd, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
View(mat_crowd)
dim(mat_crowd)[0]
#INLA_mat_crowd = my_function(mat_crowd, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
dim(mat_crowd)[1]
#INLA_mat_crowd = my_function(mat_crowd, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
dim(mat_crowd)[1][1]
#INLA_mat_crowd = my_function(mat_crowd, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
INLA_mat_crowd = my_function(mat_crowd, constr=list(A=matrix(1, nrow=1, ncol=12),e=0))
INLA_mat_disabl = my_function(mat_disabl, constr=list(A=matrix(1, nrow=1, ncol=11),e=0))
INLA_mat_limeng = my_function(mat_limeng, constr=list(A=matrix(1, nrow=1, ncol=16),e=0))
INLA_mat_pci = my_function(mat_pci, constr=list(A=matrix(1, nrow=1, ncol=10),e=0))
INLA_mat_uninsur = my_function(mat_uninsur, constr=list(A=matrix(1, nrow=1, ncol=8),e=0))
INLA_mat_crowd$fac
#INLA_mat_disabl
#INLA_mat_limeng
#INLA_mat_pci
#INLA_mat_uninsur
print("crowd ", INLA_mat_crowd$fac)
print("crowd", INLA_mat_crowd$fac)
print("crowd"+ INLA_mat_crowd$fac)
INLA_mat_crowd$fac
INLA_mat_crowd$var
INLA_mat_disabl$fac
INLA_mat_disabl$var
INLA_mat_limeng$fac
INLA_mat_limeng$var
INLA_mat_pci$fac
INLA_mat_pci$var
INLA_mat_uninsur$fac
INLA_mat_uninsur$var
det(INLA_mat_uninsur)
INLA_mat_uninsur$fac
INLA_mat_uninsur$var
det(mat_uninsur)
INLA_mat_pci$fac
INLA_mat_pci$var
det(mat_pci)
INLA_mat_limeng$fac
INLA_mat_limeng$var
det(mat_limeng)
INLA_mat_disabl$fac
INLA_mat_disabl$var
det(mat_disabl)
INLA_mat_crowd$fac
INLA_mat_crowd$var
det(mat_crowd)
